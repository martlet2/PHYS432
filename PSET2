"""
This produce an animation of the "leapfrog effect" produced by two consecutive smoke rings.
In the animation we can see four vortices move. Those four vortices correspond to the cross 
section of the two smoke rings. We can also see the velocity field generated by those four vortices. 

@author: Nicolas Desjardins 
@collab: Jules Faucher 
10/02/2022 (DD/MM/YY)
"""

import numpy as np
import matplotlib.pyplot as pl

dt =  1 # timestep
Nsteps = 60 # total number of timesteps

## Setting up initial conditions (vortex centres and circulation) 
## Vortex rings
y_v = np.array([-4,-4,4,4], float) # sets the y-position of the vortices center
x_v = np.array([-11,-6,-11,-6], float) # sets the x-position of the vortices center
k_v = np.array ([ -1.5,-1.5,1.5,1.5]) # sets the circulation of the vortices

# Setting up the plot
pl.ion ()
fig,ax = pl.subplots(1,1)

# mark the initial positions of vortices
p, = ax.plot(x_v, y_v, 'k+', markersize=10)
#play around with the marker size and type as you see fit

# draw the initial velocity streamline
ngrid = 16 #insert the dimension of your simulation grid
Y, X = np.mgrid[-ngrid:ngrid:360j, -ngrid:ngrid:360j]
#360j sets the resolution of the cartesian grid; play around with it as you see fit
vel_x = np.zeros(np.shape(X)) #this holds x−velocity 
vel_y = np.zeros(np.shape(Y)) #this holds y−velocity

# masking radius for better visualization of the vortex centres 

r_mask = 0.8 #IMPORTANT : in code we will actually be masking (r_mask)^(1/2) for simplicity
#within this mask, we will not plot any streamline
#so that we can see more clearly the movement of the vortex centres

for i in range(len(x_v)): #looping over each vortex

    d_y = Y - y_v[i] #Computing the distance between the points
    d_x = X - x_v[i] #in the grid and the center of the vortex

    r_2 = d_y*d_y+d_x*d_x #computing the radial distance squared of those points 

 # Wikipage on polar coordinates says phi_hat = (-sin(phi), cos(phi)). 
 # We know that x = r*cos(phi) => cos(phi) = x/r  and y = r*sin(phi) => sin(phi)= y/r.
 # => phi_hat = (-y/r, x/r)
 # So given that u = k/r*phi_hat we get u_y = (k_v[i]/r)*(d_x/r) = k_v[i]*d_x/r^2
 # and u_x = -(k_v[i]/r)*(d_y/r) = - k_v[i]*d_y/r^2

    vel_y += k_v[i]*d_x/r_2  #adding the velocity field of each vortex to the overall 
    vel_x += -k_v[i]*d_y/r_2 #velocity field  

    # Masking a radius of size (r_mask)^(1/2) around the center of the vortices
    vel_y = np.where( r_2 < r_mask, np.nan, vel_y) # This uses the r_2 grid to check for place with r^2 < r_mask
    vel_x = np.where( r_2 < r_mask, np.nan, vel_x) # then replace those location in the (vel_x) x (vel_y) grid

# set up the boundaries of the simulation box 
ax.set_xlim([-ngrid, ngrid])
ax.set_ylim([-ngrid, ngrid])

# initial plot of the streamlines 
ax.streamplot(X, Y, vel_x , vel_y , density=[1,1])
#play around with density as you see fit; 
#see the API documentation for more detail

fig.canvas.draw()

# Evolution
count = 0
while count < Nsteps :
    ## Compute and update advection velocity 
    advec_x = np.zeros(len(y_v)) #Empty arrays which will take the advection velocities
    advec_y = np.zeros(len(y_v))
    
    for i in range(len(x_v)):
        
        neighbours_index = np.array([((i+1) %4),((i+2) %4),((i+3) %4)]) #The vortices are "labeled"
        #with an assocatied index in the vel_x array which range from 0 to 3
        #this create an array with the index of all the neighbouring vortices execpt 
        #the one of interest
        neighbours_y = np.array([y_v[neighbours_index[0]],y_v[neighbours_index[1]],y_v[neighbours_index[2]]])
        neighbours_x = np.array([x_v[neighbours_index[0]],x_v[neighbours_index[1]],x_v[neighbours_index[2]]])
        neighbours_k = np.array([k_v[neighbours_index[0]],k_v[neighbours_index[1]],k_v[neighbours_index[2]]])


        dy = y_v[i] - neighbours_y #Arrays containing the distance between the vortex of interest
        dx = x_v[i] - neighbours_x # and its neighbours

        r2 = dy*dy+dx*dx #Array containing the radial distance squared between the vortex of interest
        #and its neighbours

        

        advec_y[i] += np.sum(neighbours_k*dx/r2) #Compute the net advection velocity caused 
        advec_x[i] += np.sum(-neighbours_k*dy/r2)# by the neighbouring vortices
        
    y_v += advec_y*dt #Change in position of the vortices in the intervall dt 
    x_v += advec_x*dt 

     # insert lines to re−initialize the total velocity field
    vel_x = np.zeros(np.shape(X)) #this holds x−velocity 
    vel_y = np.zeros(np.shape(Y)) #this holds y−velocity

    for i in range(len(x_v)): #Exactly the same thing as the first loop

        d_y = Y - y_v[i] #Computing the distance between the points
        d_x = X - x_v[i] #in the grid and the center of the vortex

        r_2 = d_y*d_y+d_x*d_x #computing the radial distance squared of those points 

        # Wikipage on polar coordinates says phi_hat = (-sin(phi), cos(phi)). 
        # We know that x = r*cos(phi) => cos(phi) = x/r  and y = r*sin(phi) => sin(phi)= y/r.
        # => phi_hat = (-y/r, x/r)
        # So given that u = k/r*phi_hat we get u_y = (k_v[i]/r)*(d_x/r) = k_v[i]*d_x/r^2
        # and u_x = -(k_v[i]/r)*(d_y/r) = - k_v[i]*d_y/r^2

        vel_y += k_v[i]*d_x/r_2  #adding the velocity field of each vortex to the overall 
        vel_x += -k_v[i]*d_y/r_2 #velocity field  

        # Masking a radius of size (r_mask)^(1/2) around the center of the vortices
        vel_y = np.where( r_2 < r_mask, np.nan, vel_y) # This uses the r_2 grid to check for place with r^2 < r_mask
        vel_x = np.where( r_2 < r_mask, np.nan, vel_x) # then replace those location in the (vel_x) x (vel_y) grid


    ## update plot

    # the following two lines clear out the previous streamlines 
    ax.collections = []
    ax.patches = []

    p.set_xdata(x_v) 
    p.set_ydata(y_v)

    ax.streamplot(X, Y, vel_x , vel_y , density=[1, 1])

    fig.canvas.draw()
    pl.pause (0.001) #play around with the delay time for better visualization
    count += 1
